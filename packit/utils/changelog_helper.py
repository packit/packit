# Copyright Contributors to the Packit project.
# SPDX-License-Identifier: MIT

import shutil
import logging
from typing import Optional

from packit.actions import ActionName
from packit.config.common_package_config import CommonPackageConfig
from packit.distgit import DistGit
import packit.upstream

logger = logging.getLogger(__name__)


class ChangelogHelper:
    def __init__(
        self,
        upstream: "packit.upstream.Upstream",
        downstream: Optional[DistGit] = None,
        package_config: Optional[CommonPackageConfig] = None,
    ) -> None:
        self.up = upstream
        self.dg = downstream
        self.package_config = package_config

    @staticmethod
    def resolve_release_suffix(
        package_config: CommonPackageConfig,
        release_suffix: Optional[str] = None,
        default_release_suffix: bool = False,
    ) -> Optional[str]:
        """
        Resolves the release suffix value, since it can be set from multiple places
        and also overriden to the default one that is generated by packit.

        Args:
            package_config: Package config that is used as fallback.
            release_suffix: Release suffix that was passed from CLI.
            default_release_suffix: Override for using the default one that ensures
                correct NVR ordering.

        Returns:
            `None` if packit is to use the default method of generating release
            suffix, otherwise string containing the release suffix.
        """
        if default_release_suffix:
            # we want to use the default packit-generated release suffix
            release_suffix = None
        elif release_suffix is None:
            # we want to get release suffix from the configuration
            release_suffix = package_config.release_suffix
        return release_suffix

    @property
    def entry_from_action(self) -> Optional[str]:
        """
        Runs changelog-entry action if present and returns string that can be
        used as a changelog entry.

        Returns:
            Changelog entry or `None` if action is not present.
        """
        messages = self.up.get_output_from_action(ActionName.changelog_entry)
        if not messages:
            return None

        return "\n".join(map(lambda line: line.rstrip(), messages))

    def update_dist_git(self, full_version: str, upstream_tag: str) -> None:
        """
        Update the spec-file in dist-git by setting the 'Version' tag and
        adding a new entry in the %changelog section.
        If downstream spec file has the %autochangelog macro then
        preserve it and do not write a comment to the %changelog section.

        Args:
            full_version: Version to be set in the spec-file.
            upstream_tag: The commit messages after last tag and before this tag are used
                to update the changelog in the spec-file.
        """
        comment = self.entry_from_action or (
            self.up.local_project.git_project.get_release(
                tag_name=upstream_tag, name=full_version
            ).body
            if self.package_config.copy_upstream_release_description
            else self.up.get_commit_messages(
                after=self.up.get_last_tag(upstream_tag), before=upstream_tag
            )
        )
        try:
            self.dg.set_specfile_content(
                self.up.specfile,
                full_version,
                comment=None if self.dg.specfile.has_autochangelog else comment,
            )
        except FileNotFoundError as ex:
            # no downstream spec file: this is either a mistake or
            # there is no spec file in dist-git yet, hence warning
            logger.warning(
                f"Unable to find a spec file in downstream: {ex}, copying the one from upstream."
            )
            shutil.copy2(
                self.up.absolute_specfile_path,
                self.dg.get_absolute_specfile_path(),
            )

    def _get_release_for_source_git(
        self, current_commit: str, bump_version: bool, release_suffix: Optional[str]
    ) -> Optional[str]:
        old_release = self.up.specfile.expanded_release
        if release_suffix:
            return f"{old_release}.{release_suffix}"

        if not bump_version:
            return None

        try:
            old_release_int = int(old_release)
            new_release = str(old_release_int + 1)
        except ValueError:
            new_release = str(old_release)

        return f"{new_release}.g{current_commit}"

    def prepare_upstream_using_source_git(
        self, bump_version: bool, release_suffix: Optional[str]
    ) -> None:
        """
        Updates changelog when creating SRPM within source-git repository.
        """
        current_commit = self.up.local_project.commit_hexsha
        release_to_update = self._get_release_for_source_git(
            current_commit, bump_version, release_suffix
        )

        msg = self.entry_from_action
        if not msg and bump_version:
            msg = f"- Downstream changes ({current_commit})"
        self.up.specfile.release = release_to_update
        if msg is not None:
            self.up.specfile.add_changelog_entry(msg)

    def prepare_upstream_locally(
        self,
        version: str,
        commit: str,
        bump_version: bool,
        release_suffix: Optional[str],
    ) -> None:
        """
        Updates changelog when creating SRPM within upstream repository.

        Args:
            version: Version to be set in the spec-file.
            commit: Commit to be set in the changelog.
            bump_version: Specifies whether version should be changed in the spec-file.
            release_suffix: Specifies local release suffix. `None` represents default suffix.
        """
        last_tag = self.up.get_last_tag()
        msg = self.entry_from_action
        if not msg and last_tag and bump_version:
            msg = self.up.get_commit_messages(after=last_tag)
        if not msg and bump_version:
            # no describe, no tag - just a boilerplate message w/ commit hash
            # or, there were no changes b/w HEAD and last_tag, which implies last_tag == HEAD
            msg = f"- Development snapshot ({commit})"
        release = self.up.get_spec_release(
            bump_version=bump_version,
            release_suffix=release_suffix,
        )
        logger.debug(f"Setting Release in spec to {release!r}.")
        # instead of changing version, we change Release field
        # upstream projects should take care of versions
        self.up.specfile.set_version_and_release(version, release)
        if msg is not None:
            self.up.specfile.add_changelog_entry(msg)
